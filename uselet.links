# Namer

typename Address = Int;
typename AddressSource = () {}~> Address;

sig makeAddr : (AddressSource) {}~> (Address, AddressSource)
fun makeAddr (source) {
  var addr = source();
  (addr, fun () { addr + 1 })
}

var addressInit = fun () { 0 } : AddressSource;


# Dispatcher

fun dispatchFun (clients) {
  receive {
    case Register(c)    -> { dispatchFun(c :: clients) }
    case Deregister(c)  -> dispatchFun(filter(fun (x) { x <> c }, clients))
    case Ignore         -> dispatchFun(clients)
    case Send(msg, to)  -> {
      var tmp =
        for (c <- clients)
        # where (c.addr == to)
          [ c ! msg ];
      dispatchFun(clients)
    }
    case Broadcast(msg) -> {
      var tmp = for (c <- clients) [
        # if c accepts msg (by type)
        c ! msg
      ];
      dispatchFun(clients)
    }
  }
}

op disp <! msg {
  disp ! Broadcast(msg)
}

op disp <!@ (msg, to) {
  disp ! Send(msg, to)
}

fun using (disp, plugin) {
  fun helper () {
    receive {
      case msg -> { disp ! plugin(msg); helper() }
    }
  }
  spawnClient { helper() }
}

fun log (logPrefix)(msg) { print(logPrefix ^^ " " ^^ show(msg)); msg }

fun spawnDispatcher () {
  spawnClient { dispatchFun([ ]) } `using` log("[Dispatcher]")
}


# Renderer

sig makeTag : (String, [(String, String)], Xml) ~> Xml
fun makeTag (name, attributes, content) {
  # TODO
  var id = fromJust(lookup("id", attributes));

  <div id="{ id }">
    { content }
  </div>
}

sig resolveDOMDiff : (DomNode, Xml) ~> ()
fun resolveDOMDiff (subject, targetState) {
  replaceNode(targetState, subject)
}

var nodeAddrPrefix = "_render_node_";

fun rendererFun () client {
  receive {
    case Changed(addr, render, model) -> {
    # case Changed(subject, model) -> {
      var id = nodeAddrPrefix ^^ intToString(addr);

      var targetDOM = render(addr, model);

      var currentDOM = getNodeById(id);
      resolveDOMDiff(currentDOM, targetDOM);
      rendererFun()
    }
  }
}

fun spawnRenderer () {
  spawnClient { rendererFun() } `using` log("[Renderer]")
}


# Uselet

fun uselet(name, model, updt, view) {
  fun (addressSource, services, dispatcher, renderer) {
    var (addr, gen) = makeAddr(addressSource);

    fun emit (msg) {
      dispatcher <! msg
    }

    fun send (msg, to) {
      dispatcher <!@ (msg, to)
    }

    fun wrappedRenderFun (self, model) {
      var xml = view(emit, send)(self, model);
      var id = nodeAddrPrefix ^^ intToString(addr);
      makeTag(name, [("id", id)], xml)
    }

    var updateWithServices = updt(services);

    fun proxyFn (oldState) {
      receive {
        case msg -> {
          var newState = updateWithServices(oldState, msg);
          # var xml = subject.renderFun(subject.addr, newState);
          # renderer ! Changed(subject, newState);
          renderer ! Changed(addr, wrappedRenderFun(addr, newState));
          proxyFn(newState)
        }
      }
    }

    dispatcher ! Register(spawnClient { proxyFn(model) });

    (
      name = name,
      addr = addr,
      model = model,
      renderFun = wrappedRenderFun,
      updateFun = updateWithServices,
      gen = gen
    )
  }
}

fun useletPage (u, createServices) {
  var addrSource = addressInit;
  var dispatcher = spawnDispatcher();
  var renderer = spawnRenderer();

  var services = createServices(fun (msg) { dispatcher <! msg });

  var instance = u(addrSource, services, dispatcher, renderer);

  page
    <#>
      { instance.renderFun(instance.addr, instance.model) }
    </#>
}



