open Uselet


typename ItemId = Int;
typename Item = (id: ItemId, body: String);
typename Error = String;

typename Model = (items: [Item], value: String);

typename ListApiMessage = [| GetData | AddItem | DeleteItem: ItemId |];

typename ListMessage = [|
    Refresh
  | Data: [Item]
  | AddItem
  | AddSuccess: Item
  | DeleteItem: ItemId
  | DeleteSuccess: ItemId
  | APIError: String
  | ValueChanged:DomNode
|];


# API
var db = database "uselet";

var listItemsTable = table "items"
  with (id: Int, body: String)
  where id readonly
  from db;

fun mockApiFun (entries, idSeed)(emit) {
  receive {
    case GetData -> { emit(Data(entries)); mockApiFun(entries, idSeed)(emit) }
    case AddItem -> {
      var item = (id = idSeed, body = intToString(idSeed));
      emit(AddSuccess(item));
      mockApiFun(item :: entries, idSeed + 1)(emit)
    }
    case DeleteItem(id) -> {
      emit(DeleteSuccess(id));
      mockApiFun(filter(fun (e) { e.id <> id }, entries), idSeed)(emit)
    }
  }
}

# fun insertItem (body) server {
#   insert listItemsTable values (body) [
#     (body = body)
#   ]
# }

# fun apiFun (emit) {
#   receive {
#     case GetData -> {
#       var data = for (item <-- listItemsTable)
#         [ item ];

#       emit(Data(data));
#       apiFun(emit)
#     }
#     case AddItem -> {
#       var item = insertItem("Lorem ipsum");
#       emit(AddSuccess(item));
#       # on error emit(APIError(err))
#       apiFun(emit)
#     }
#     case DeleteItem(id) -> {
#       delete (item <-- listItemsTable)
#         where (item.id == id);
#       emit(DeleteSuccess(id));
#       # on error emit(APIError(err))
#       apiFun(emit)
#     }
#   }
# }

fun spawnApiService (emit) {
  spawnClient { mockApiFun([], 0)(emit) }
}


# Uselet

sig listUpdateFun : ((listApi:Process ({ hear:ListApiMessage|_ })|_)) -> (Model, ListMessage) ~> Model
fun listUpdateFun (services)(model, msg) {
  switch (msg) {
    case ValueChanged(eventTarget: DomNode) -> {
      var newValue = domGetAttributeFromRef(eventTarget, "value");
      ( model with value = newValue )
    }

    case Refresh -> { services.listApi ! GetData; model }
    case Data(data: [Item]) -> ( model with items = data )

    case AddItem -> { services.listApi ! AddItem; model }
    case AddSuccess(item: Item) -> ( model with items = item :: model.items )

    case DeleteItem(id: ItemId) -> { services.listApi ! DeleteItem(id); model }
    case DeleteSuccess(id: ItemId) -> ( model with items = filter(fun (i) { i.id <> id }, model.items) )

    case APIError(err: String) -> { error(err); model }
  }
}


sig listRenderFun : ((ListMessage) ~> ()) -> (Model) ~> Xml
fun listRenderFun (send)(model) {
  <#>
    <button l:onclick="{ send(AddItem) }">Add</button>
    <ul>
      {
        for (item <- model.items) {
          <#>
          <li>{ stringToXml(item.body) }</li>
          </#>
        }
      }
    </ul>
  </#>
}


var listUselet = uselet(
  "my-list-elem",
  (value="", items=[ ]): Model,
  listUpdateFun,
  listRenderFun
);



var services = fun (emit) {
  (
    listApi = spawnApiService(emit) `using` log("[ListAPI]"): Process ({ hear:ListApiMessage,wild|_ })
  )
};


fun main () {
  addRoute("/u", fun (_, _) {

    page
      <main>
  	    {| useletPage(listUselet,  services) |}
      </main>
  });

  servePages()
}

main()

# Uselet.dispatchFun