typename Ord = [| LT | GT | EQ |];
typename BinaryTree(key, value) = [| Node: (key, Maybe(value), BinaryTree(key, value), BinaryTree(key, value)) | Leaf |];

var emptyTree = Leaf;

fun treeInsert (key, value, compare, tree) {
  switch (tree) {
    case Leaf -> Node(key, Just(value), Leaf, Leaf)
    case Node(k, v, l, r) -> switch (compare(key, k)) {
      case EQ -> Node(k, Just(value), l, r)
      case LT -> Node(k, v, treeInsert(key, value, compare, l), r)
      case GT -> Node(k, v, l, treeInsert(key, value, compare, r))
    }
  }
}

fun treeFromList (kvps, compare) {
  fold_left(fun (t, kvp) { var (k, v) = kvp; treeInsert(k, v, compare, t) }, emptyTree, kvps)
}

fun treeToList (tree) {
  switch (tree) {
    case Leaf -> [ ]
    case Node(k, v, l, r) -> {
      fun filterJustToValue (xs) {
        switch (xs) {
          case [ ] -> [ ]
          case (k, Nothing) :: t -> filterJustToValue(t)
          case (k, Just(v)) :: t -> (k, v) :: filterJustToValue(t)
        }
      }
      filterJustToValue((k, v) :: treeToList(l) ++ treeToList(r))
    }
  }
}

fun treeMapValues (f, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(k, Nothing, l, r) -> Node(k, Nothing, treeMapValues(f, l), treeMapValues(f, r))
    case Node(k, Just(v), l, r) -> Node(k, Just(f(v)), treeMapValues(f, l), treeMapValues(f, r))
  }
}

fun treeForEachValue (f, tree) {
  switch (tree) {
    case Leaf -> ()
    case Node(k, Nothing, l, r) -> ()
    case Node(k, Just(v), l, r) -> {
      f(v);
      treeForEachValue(f, l);
      treeForEachValue(f, r);
    }
  }
}

fun treeLookup (key, compare, tree) {
  switch (tree) {
    case Leaf -> Nothing
    case Node(k, v, l, r) -> switch (compare(key, k)) {
      case EQ -> v
      case LT -> treeLookup(key, compare, l)
      case GT -> treeLookup(key, compare, r)
    }
  }
}

fun treeRemove (key, compare, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(k, v, l, r) -> switch (compare(key, k)) {
      case EQ -> Node(k, Nothing, l, r)
      case LT -> treeRemove(key, compare, l)
      case GT -> treeRemove(key, compare, r)
    }
  }
}

# Namer

typename Address = [Int];
typename AddressSource = () {}~> Address;

# Generate a fresh Address from an AddressSource
# @param {AddressSource}
# @returns {(Address, AddressSource)} Pair of the generated Address and an updated generator
sig makeAddr : (AddressSource) {}~> (Address, AddressSource)
fun makeAddr (source) {
  var address = source();
  (address, fun () { var h :: t = address; (h + 1) :: t })
}

sig makeSource : (Address) {}~> AddressSource
fun makeSource (address) {
  fun () { 0 :: address }
}

sig addrToString : (Address) {}~> String
fun addrToString (addr) {
  switch (addr) {
    case [ ] -> error("Empty address")
    case (h :: t) -> fold_left(fun (prev, curr) { intToString(curr) ^^ "-" ^^ prev }, intToString(h), t)
  }
}

var initialSource = fun () { [ 0 ] } : AddressSource;


# Dispatcher

typename DispatcherMessage = forall a, b.
[| Deregister: Address
  | Ignore
  | Send: (a, Address)
  | Broadcast: a
  | Register: (Address, b)
  |];
typename Dispatcher = Process ({ hear:DispatcherMessage,wild });

# Dispatcher handler
# Forward messages to their correct recipient(s)
# @param {[(Address, fun]} clients
# @returns {()}
# sig dispatchFun : ([(Address, (b) {:DispatcherMessage}~> () )]) {:DispatcherMessage} ~> ()
sig dispatchFun : (BinaryTree(Address, (b) {:DispatcherMessage}~> ())) {:DispatcherMessage} ~> ()
fun dispatchFun (clients) client {
  fun addrComp (a, b) {
    switch ((a, b)) {
      case ([ ], [ ]) -> EQ
      case ([ ], _) -> LT
      case (_, [ ]) -> GT
      case (h1 :: t1, h2 :: t2) ->
        if (h1 == h2) addrComp(t1, t2)
        else if (h1 < h2) LT
        else GT
    }
  }

  receive {
    case Register(addr, send) -> { dispatchFun(treeInsert(addr, send, addrComp, clients)) }
    case Deregister(addr)  -> dispatchFun(treeRemove(addr, addrComp, clients))
    case Ignore -> dispatchFun(clients)
    case Send(msg, to) -> {
      switch (treeLookup(to, addrComp, clients)) {
        case Nothing -> ()
        case Just(send) -> send(msg)
      };
      dispatchFun(clients)
    }
    case Broadcast(msg) -> {
      treeForEachValue(fun (send) { send(msg) }, clients);
      dispatchFun(clients)
    }
  }
}

# Broadcast
sig <! : (Process ({ hear:DispatcherMessage,wild }), b) ~> ()
op disp <! msg {
  disp ! (Broadcast(msg) : DispatcherMessage)
}

# Directed send
sig <@ : (Process ({ hear:DispatcherMessage,wild }), (b, Address)) ~> ()
op disp <@ (msg, to: Address) {
  disp ! (Send(msg, to) : DispatcherMessage)
}

# Mix in function applied to all messages received
# @param {Process} The recipient of the message
# @param {fun} Mutator for the messages
# @returns {Process}
sig using : forall m::Any. (Process({ hear: a,wild }), (b) {:b}~> a) ~> Process({ hear: b,wild })
fun using (recp, plugin) {
  fun helper () {
    receive {
      case msg -> { recp ! plugin(msg); helper() }
    }
  }
  spawnClient { helper() }
}

sig log : (String) ~> (b) ~> b
fun log (logPrefix)(msg) { print(logPrefix ^^ " " ^^ show(msg)); msg }

# @returns {Process} Dispatcher process with logging
sig spawnDispatcher : () ~> Process ({ hear:DispatcherMessage,wild })
fun spawnDispatcher () {
  spawnClient { dispatchFun(emptyTree) } `using` log("[Dispatcher]")
}


# Rendering

sig makeTag : (String, [(String, String)], Xml) ~> Xml
fun makeTag (name, attributes, content) {
  # makeXml(name, attributes, content)
  # TODO
  var id = fromJust(lookup("id", attributes));

  <div is="{ name }" id="{ id }">
    { content }
  </div>
}

# Resolve diff of two DOM (sub-)trees
# @param {DomNode} subject DOM Subtree to mutate into target state
# @param {Xml} targetState Xml representation the subject is to be in
# @returns {()}
sig resolveDOMDiff : (DomNode, Xml) ~> ()
fun resolveDOMDiff (subject, targetState) client {
  replaceNode(targetState, subject)
  # replaceChildrenInShadow(subject, targetState);
}

# Uselet

typename Uselet(services) = forall y::Row. (
  AddressSource,
  Services,
  Process ({ hear:DispatcherMessage,wild })
) { |y}~> (
  Xml,
  AddressSource
);

typename Services = forall a :: Row. ( |a);

var nodeAddrPrefix = "_render_node_";

# Create uselet from name, model, update, and view
# @param {String} Name
# @param {_} Model
# @param {fun} Update function
# @param {fun} View function
# @returns {Uselet}
sig uselet : (
  String,
  model,
  (Services) {}~> (model, msg) {:msg|%}~> model,
  forall z :: Row. ((e) ~> ()) { |z}~> (model) { |z}~> Uselet(Services)
) -> Uselet(Services)

fun uselet(name, model, updt, view) {
  fun (addressSource, services, dispatcher) {

    var (addr, gen) = makeAddr(addressSource);
    var childGen = makeSource(addr);
    var id = nodeAddrPrefix ^^ addrToString(addr);

    fun send (msg) { dispatcher <@ (msg, addr) }
    fun emit (msg) { dispatcher <! (msg) }

    var updateWithServices = updt(services);

    fun handler (oldState) {
      receive {
        case msg -> {
          var newState = updateWithServices(oldState, msg);
          var (xml, _) = view(send)(newState)(childGen, services, dispatcher);
          var targetDOM = makeTag(name, [("id", id)], xml);
          var currentDOM = getNodeById(id);
          resolveDOMDiff(currentDOM, targetDOM);

          handler(newState)
        }
      }
    }

    var handler = spawnClient { handler(model) };
    dispatcher ! Register(addr, fun (msg) { handler ! msg });

    var (xml, _) = view(send)(model)(childGen, services, dispatcher);
    var elem = makeTag(name, [("id", id)], xml);

    (elem, gen)
  }
}

fun xmlUselet (xml) {
  fun (gen, _, _) { (xml, gen) }
}


fun textUselet (str) {
  fun (gen, _, _) { (stringToXml(str), gen) }
}

fun useletApp (name, child, servicesFn) {
  var dispatcher = spawnDispatcher();
  var services = servicesFn(fun (msg) { dispatcher <! msg});

  var (xml, gen) = child(initialSource, services, dispatcher);
  (makeTag(name, [("id", "")], xml), gen) # TODO
}

op u1 <+> u2 {
  fun (addrSource, services, dispatcher) {
    var (xml1, gen1) = u1(addrSource, services, dispatcher);
    var (xml2, gen2) = u2(gen1, services, dispatcher);
    (<#>
      { xml1 }
      { xml2 }
    </#>, gen2)
  }
}


op xmlItem +> u {
  fun (addrSource, services, dispatcher) {
    var (xml, gen) = u(addrSource, services, dispatcher);
    (makeTag(xmlItem, [("id", "")], xml), gen) # TODO
  }
}











# # kanbanBoardUselet


# fun kanbanCardUselet (id, head, body) {
#   uselet(
#     "kanbancard",
#     ( id = id, head = head, body = body ),
#     fun (services)(model, _) {
#       # TODO
#       model
#     },
#     fun (send)(model) {
#       <#>
#         <a class="btn-round">x</a>
#         {
#           if (strlen(model.head) > 0)
#             <h4 class="card-head">{ stringToXml(model.head) }</h4>
#           else
#             <#/>
#         }
#         {
#           if (strlen(body) > 0)
#             <span class="card-body">{ stringToXml(model.body) }</span>
#           else
#             <#/>
#         }
#       </#>
#     }
#   )
# }


# fun kanbanColumnUselet (id, title, cards) {
#   uselet(
#     "kanbancolumn",
#     ( id = id, title = title, cards = cards ),
#     fun (services)(model, msg) {
#       # TODO
#       model
#     },
#     fun (send)(model) {
#       <#>
#         <div class="board-col-head">
#           <h4>{ stringToXml(model.title) }</h4>
#           <a class="btn-round"> x </a>
#         </div>
#         <ul id="{ id }" class="board-col-body">
#           <a class="ghost-btn"> + </a>
#         </ul>
#       </#>
#     }
#   )
# }





fun errorUselet (err) {
  xmlUselet(<#>
    <style>.error {{ color: rgb(192, 0, 0); border: thin solid rgb(192, 0, 0); background-color: rgba(255, 0, 0, 0.25); padding: .5rem; }}</style>
    <div class="error">{ err }</div>
  </#>)
}


typename ItemId = Int;
typename Item = (id: ItemId, body: String);
typename Error = String;

typename Model = (items: [Item], value: String);

typename ListApiMessage = [| GetData | AddItemWithBody: String | DeleteItem: ItemId |];

typename ListMessage = [|
    Refresh
  | Data: [Item]
  | AddItem
  | AddSuccess: Item
  | DeleteItem: ItemId
  | DeleteSuccess: ItemId
  | APIError: String
  | ValueChanged: String
|];


var db = database "uselet";

var listItemsTable = table "items"
  with Item
  where id readonly
  from db;

fun getAllListItems () {
  for (i <-- listItemsTable)
    [ i ]
}

fun insertItem (body) {
  insert listItemsTable values (body) [
    (body = body)
  ]
}

sig apiFun : ((ListMessage) {:ListApiMessage}~> ()) {:ListApiMessage}~> ()
fun apiFun (emit) {
  receive {
    case GetData -> {
      var entries = getAllListItems();
      emit(Data(entries));
      apiFun(emit)
    }
    case AddItemWithBody(body) -> {
      # insertItem(body);
      var item = ( id = -1, body = body );
      emit(AddSuccess(item));
      apiFun(emit)
    }
    case DeleteItem(id) -> {
      emit(DeleteSuccess(id));
      apiFun(emit)
    }
  }
}

sig spawnApiService : ((ListMessage) {:ListApiMessage}~> ()) ~> Process ({ hear:ListApiMessage,wild })
fun spawnApiService (emit) {
  spawnClient { apiFun(emit) }
}


fun listUpdateFun (services)(model, msg) {
  switch (msg) {
    case ValueChanged(newValue) -> {
      ( model with value = newValue )
    }

    case Refresh -> { services.listApi ! GetData; model }
    case Data(data: [Item]) -> ( model with items = data )

    case AddItem -> {
      services.listApi ! AddItemWithBody(model.value);
      model
    }
    case AddSuccess(item: Item) -> ( model with items = item :: model.items, value = "" )

    case DeleteItem(id: ItemId) -> { services.listApi ! DeleteItem(id); model }
    case DeleteSuccess(id: ItemId) -> ( model with items = filter(fun (i) { i.id <> id }, model.items) )

    case APIError(err: String) -> { error(err); model }
  }
}


fun listRenderFun (send)(model: Model) {
  var list = fold_left(fun (res, curr) { res <+> listItemUselet(curr.body) }, xmlUselet(<#/>), model.items);

  xmlUselet(<style>
    ul {{ font-family: sans-serif; margin: 1rem 0; padding: 0; }}
    li {{ display: block; list-style-type: none; border-bottom: thin solid #ccc; padding: .5rem; }}
    li:last-child {{ border: none; }}
    li:nth-of-type(2n) {{ background-color: #eee; }}
  </style>) <+>
  xmlUselet(<input type="text" value="{ model.value }" l:onkeyup="{ send(ValueChanged(domGetPropertyFromRef(getTarget(event), "value"))) }" />) <+>
  xmlUselet(<button l:onclick="{ send(AddItem) }">Add</button>) <+>
  list
}


fun listUselet () {
  uselet(
    "mylistelem",
    ( value = "", items = getAllListItems() ): Model,
    listUpdateFun,
    listRenderFun
  )
}

sig services : ((ListMessage) {:ListApiMessage}~> ()) ~> Services
fun services(emit) {
  ( listApi = spawnApiService(emit) )
}


fun myApp () {
  var (app, _) = useletApp("myapp",
    ("div" +> (textUselet("Hello") <+>
    xmlUselet(<strong>World</strong>))) <+>
    errorUselet(<h1>I am an error</h1>) <+>
    listUselet() <+>
    listUselet() <+>
    # kanbanCardUselet(0, "Hello", "World") <+>
    staticListUselet([ "Hello", "World" ]),
  services);

  page
    <html>
      <head>
        <meta charset="utf-8" />
        <title>My App</title>
        <link rel="stylesheet" href="/css/style.css" />
      </head>
      <body>
        <header><h1>Kanban</h1></header>
        <main>
          { app }
        </main>
      </body>
    </html>
}


fun listItemUselet (str) {
  uselet("li", (), fun (_)(m, _) { m }, fun (_)(_) { textUselet(str) })
}


fun staticListUselet (items: [String]) {
  var us = for (i <- items) [ listItemUselet(i) ];
  if (length(us) < 1) { xmlUselet(<ul/>) }
  else if (length(us) == 1) { "ul" +> hd(us) }
  else {
    "ul" +> fold_left(fun (curr, prev) { curr <+> prev }, hd(us), tl(us))
  }
}



sig main : () ~> ()
fun main () {
  addStaticRoute("/css", "css", [
    ("css", "text/css")
  ]);

  addRoute("/u", fun (_, _) { myApp() });

  servePages()
}

main()
