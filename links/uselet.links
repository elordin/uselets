# Namer

typename Address = Int;
typename AddressSource = () {}~> Address;

sig makeAddr : (AddressSource) {}~> (Address, AddressSource)
fun makeAddr (source) {
  var addr = source();
  (addr, fun () { addr + 1 })
}

var addressInit = fun () { 0 } : AddressSource;


# Dispatcher

fun dispatchFun (clients) {
  receive {
    case Register(addr, c)    -> { dispatchFun((addr, c) :: clients) }
    case Deregister(addr)  -> dispatchFun(filter(fun (x) { var (a, c) = x; a <> addr }, clients))
    case Ignore         -> dispatchFun(clients)
    case Send(msg, to)  -> {
      switch (lookup(to, clients)) {
        case Nothing -> ()
        case Just(c) -> c ! msg
      };
      dispatchFun(clients)
    }
    case Broadcast(msg) -> {
      var tmp = for ((addr, c) <- clients) [
        # if c accepts msg (by type)
        c ! msg
      ];
      dispatchFun(clients)
    }
  }
}

op disp <! msg {
  disp ! Broadcast(msg)
}

op disp <!@ (msg, to) {
  disp ! Send(msg, to)
}

fun using (disp, plugin) {
  fun helper () {
    receive {
      case msg -> { disp ! plugin(msg); helper() }
    }
  }
  spawnClient { helper() }
}

fun log (logPrefix)(msg) { print(logPrefix ^^ " " ^^ show(msg)); msg }

fun spawnDispatcher () {
  spawnClient { dispatchFun([ ]) } `using` log("[Dispatcher]")
}


# Renderer

sig makeTag : (String, [(String, String)], Xml) ~> Xml
fun makeTag (name, attributes, content) {
  # TODO
  var id = fromJust(lookup("id", attributes));
  <div is="{ name }" id="{ id }">
    { content }
  </div>
}

sig resolveDOMDiff : (DomNode, Xml) ~> ()
fun resolveDOMDiff (subject, targetState) {
  replaceNode(targetState, subject)
}

# Uselet

fun uselet(name, model, updt, view) {
  fun (addressSource, services, dispatcher) {

    var nodeAddrPrefix = "_render_node_";
    var (addr, gen) = makeAddr(addressSource);
    var id = nodeAddrPrefix ^^ intToString(addr);

    fun send (msg) { dispatcher <!@ (msg, addr) }

    fun renderAsElement (model) {

      var xml = view(send)(model);
      makeTag(name, [("id", id)], xml)
    }

    fun reRender (newModel) {
      var targetDOM = renderAsElement(newModel);
      var currentDOM = getNodeById(id);
      resolveDOMDiff(currentDOM, targetDOM)
    }

    var updateWithServices = updt(services);

    fun handler (oldState) {
      receive {
        case msg -> {
          var newState = updateWithServices(oldState, msg);
          reRender(newState);
          handler(newState)
        }
      }
    }

    dispatcher ! Register(addr, spawnClient { handler(model) });

    # renderAsElement(model)
    (<div id="{id}"><button l:onclick="{ send(Refresh) }">Init</button></div>, gen)
  }
}

fun useletPage (u, createServices) {
  var addrSource = addressInit;
  var dispatcher = spawnDispatcher();

  var services = createServices(fun (msg) { dispatcher <! msg });

  var (xml1, gen1) = u(addrSource, services, dispatcher);
  var (xml2, gen2) = u(gen1, services, dispatcher);

  page
    <#>
      { xml1 }
      { xml2 }
    </#>
}
