# Framework definitions



fun makeProcesses () {
  var renderer = spawnClient { rendererFun() };
  var dispatcher = spawnClient { dispatchFun([ ]) } `using` log("[Dispatcher]");
  (dispatcher, renderer)
}

fun makeAttachFun (d, r) {
  fun (subject) {
    fun proxyFn (oldState) {
      receive {
        case msg -> {
          var newState = subject.updateFun(oldState, msg);
          # var xml = subject.renderFun(newState);
          # r ! Changed(subject, newState);
          proxyFn(newState)
        }
      }
    }

    d ! Register(spawnClient { proxyFn(subject.model) });
    subject
  }
}




# User code

# List example

typename ItemId = Int;
typename Item = (id: ItemId, body: String);
typename Error = String;

typename Model = (items: [Item], value: String);

typename ListMessage = [|
    Refresh
  | Data: Model
  | AddItem: String
  | AddSuccess: Item
  | DeleteItem: ItemId
  | DeleteSuccess: ItemId
  | APIError: String
|];

typename ListApiMessage = [| GetData | AddItem: String | DeleteItem: ItemId |];

# List API

# sig mockApiFun : ([Item], ItemId) {:ListApiMessage}~> (a::Any) ~> ()
fun mockApiFun (entries, idSeed)(emit) {
  receive {
    case GetData -> { emit(Data(entries)); mockApiFun(entries, idSeed)(emit) }
    case AddItem -> {
      var item = (id = idSeed, body = intToString(idSeed));
      emit(AddSuccess(item));
      mockApiFun(item :: entries, idSeed + 1)(emit)
    }
    case DeleteItem(id) -> {
      emit(DeleteSuccess(id));
      mockApiFun(filter(fun (e) { e.id <> id }, entries), idSeed)(emit)
    }
  }
}

# sig listRenderFun : RenderFun(Model, ListMessage)
fun listRenderFun (emit)(model: Model) {
  <#>
    <input
      type="text"
      l:onkeyup="{ emit(ValueChanged(getTarget(event))) }"
      value="{ model.value }"
    />
    <button l:onclick="{ emit(AddItem) }">Add</button>
    <ul>
      {
        for (item <- model.items) {
          <#>
          <li>{ stringToXml(item.body) }</li>
          </#>
        }
      }
    </ul>
  </#>
}


# sig listUpdateFun : UpdateFun(Model, ListMessage)
fun listUpdateFun (services)(model: Model, msg) {
  switch (msg) {
    case ValueChanged(eventTarget) -> {
      var newValue = domGetAttributeFromRef(eventTarget, "value");
      ( model with value = newValue )
    }

    case Refresh -> { services.listApi ! GetData; model }
    case Data(data) -> ( model with items = data )

    case AddItem -> { services.listApi ! AddItem; model }
    case AddSuccess(item) -> ( model with items = item :: model.items )

    case DeleteItem(id) -> { services.listApi ! DeleteItem(id); model }
    case DeleteSuccess(id) -> ( model with items = filter(fun (i) { i.id <> id }, model.items) )

    case APIError(err) -> { error(err); model }

    case _ -> model
  }
}










fun uselet(name, model: Model, updt, view) {
  fun (addressSource, services, dispatcher, renderer) {
    var attach = makeAttachFun(dispatcher, renderer);
    fun emit (msg) {
      dispatcher <! msg
    }
    var (addr, gen) = makeAddr(addressSource);
    attach((
      name = name,
      addr = addr,
      model = model,
      renderFun = view(emit),
      updateFun = updt(services),
      gen = gen
    ))
  }
}

var listUselet = uselet("my-list-elem", (value="", items=[ ]): Model, listUpdateFun, listRenderFun);

fun useletPage (u, createServices) {
  var addrSource = addressInit;
  var (dispatcher, renderer) = makeProcesses();
  fun emit (msg) {
    print("Emit");
    dispatcher <! msg
  }
  var services = createServices(emit);
  var instance = u(addrSource, services, dispatcher, renderer);

  page
    <#>
      { instance.renderFun(instance.model) }
    </#>
}

